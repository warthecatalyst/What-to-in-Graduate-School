# 操作系统

## 操作系统结构
**1、什么是操作系统的内核**
操作系统的内核是操作系统中最关键的部分，它是操作系统的核心组成部分。内核控制着计算机资源的分配和调度，并为应用程序提供必要的服务和支持。它负责管理系统中的所有硬件设备，包括处理器、存储器、输入/输出设备等，并提供诸如进程管理、内存管理、文件系统管理、网络管理等功能。操作系统的内核的设计和实现非常复杂，它需要保证操作系统的稳定性、可靠性和安全性，在多任务、多用户环境下保证资源分配和调度的公平性和高效性。同时，内核也是与硬件直接交互的部分，需要考虑硬件的特性和限制，保证与硬件的兼容性。通常情况下，操作系统的内核是以底层服务的形式运行在操作系统的顶层上，为上层的应用程序提供支持和服务。

**2、内核态操作系统和用户态操作系统的区别**
操作系统中的内核代码通常运行在两种不同的特权级别：内核态和用户态。

内核态是指操作系统内核运行代码所拥有的最高特权级别。在内核态中，内核有权访问计算机中的所有资源，包括CPU、内存、I/O设备等。内核可以执行所有特权指令，如读写特殊寄存器、修改中断描述符表等操作。因此，内核态下的程序可以直接操作硬件，具有很高的权限和较高的执行效率。

相反，用户态是指应用程序运行时所拥有的特权级别。在用户态下，应用程序只能访问自己的地址空间，并不能直接访问操作系统内核或资源。应用程序不能执行特权指令，不能直接访问硬件，由操作系统来管理和分配资源。因此，用户态下的程序不能直接操作硬件，权限较低，执行效率也较低。


内核态和用户态的主要区别在于权限和资源的访问。内核态下的程序可以访问计算机中的所有资源，但需要非常小心，避免对操作系统和系统的稳定性造成危害。用户态下的程序由操作系统进行管理和调度，不能直接操作资源，但相对安全，可以保护操作系统免受用户程序的影响。

**3、有哪些方法可以从用户态切换到内核态**
从用户态切换到内核态是操作系统的核心操作之一，常见的方法有：

系统调用：用户程序可以通过系统调用来请求操作系统内核提供服务，如文件操作、网络请求等。当用户程序调用系统调用时，进入内核态来执行请求，完成后再返回用户态。

异常和中断：当硬件或软件出现异常或中断时，CPU会立即从用户态切换到内核态，让操作系统处理错误或响应中断。

用户态线程阻塞：当一个用户态线程请求等待某个事件发生时，如等待I/O操作完成或等待锁释放，操作系统会将该线程阻塞并切换到内核态，等待事件发生时再唤醒线程。

信号处理：用户程序可以通过信号来与操作系统内核进行通信。当操作系统内核向用户程序发送信号时，用户程序必须处理该信号，进入内核态来响应信号。

在任何情况下，从用户态切换到内核态都需要CPU完成一定的工作，如切换堆栈、保存现场状态等，这些操作会引入一定的开销，影响系统的性能。因此，在设计操作系统时需要权衡许多因素，如系统的响应时间、资源开销等。

## 进程、线程
**操作系统提供了哪些帮助进程实现进程同步的技术**：信号量、管程、消息传递。

### 线程之间有哪些通信方式？
共享内存和消息传递

### 进程之间有哪些同步技术
Linux下进程通信的主要手段有：
- 1.管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；    
- 2.信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期 信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上， 该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，sigaction函数重新实现了signal函数）；    
- 3.报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 4.共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针其他通信机制运行效率较低设计的。往往与其它通信机制，如信号量结合使用， 来达到进程间的同步及互斥。   
- 5.信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。             
- 6.套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix 系统上：Linux和System V的变种都支持套接字。

## 内存管理
### 内存分段
分段机制下的虚拟地址由两部分组成，段选择因子和段内偏移量。

段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。

虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

### 内存分页
在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，

## 网络系统
### 什么是零拷贝？
磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存 10 倍以上，所以针对优化磁盘的技术非常的多，比如零拷贝、直接 I/O、异步 I/O 等等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘高速缓存区，可以有效的减少磁盘的访问次数。

这次，我们就以「文件传输」作为切入点，来分析 I/O 工作方式，以及如何优化传输文件的性能。

### IO多路复用
**select**
1、用户调用select，将fd_set从用户空间拷贝到内核空间
2、内核在内核空间对fd_set遍历一遍，检查是否有就绪的socket描述符，如果没有的话，就会进入休眠，直到有就绪的socket描述符
3、内核返回select的结果给用户线程，即就绪的文件描述符数量
4、用户拿到就绪文件描述符数量后，再次对fd_set进行遍历，找出就绪的文件描述符
5、用户线程对就绪的文件描述符进行读写操作

所以时间复杂度为O(n)级别，相当于用户还要对fd_set进行遍历

**poll**
poll和select的执行过程基本类似。
相同点：
- 内核线程都需要遍历文件描述符，并且当内核返回就绪的文件描述符数量后，还需要遍历一次找出就绪的文件描述符
- 需要将文件描述符数组或链表从用户空间拷贝到内核空间
- 性能开销会随文件描述符的数量而线性增大

不同点：
- select存储的数据结构是文件描述符数组，poll采用链表
- select有最大连接数限制，poll没有最大限制，因为poll采用链表存储

**epoll**
- epoll_create创建eventpoll对象（红黑树，双链表）
- 一棵红黑树，存储监听的所有文件描述符，并且通过epoll_ctl将文件描述符添加、删除到红黑树
- 一个双链表，存储就绪的文件描述符列表，epoll_wait调用时，检测此链表中是否有数据，有的话直接返回
- 所有添加到eventpoll中的事件都与设备驱动程序建立回调关系。

时间复杂度为O(1)，当有事件就绪时，epoll_wait只需要检测就绪链表中有没有数据，如果有的话就直接返回
不需要从用户空间到内核空间频繁拷贝文件描述符集合，使用了内存映射(mmap)技术
当有就绪事件发生时采用回调的形式通知用户线程

epoll分为水平触发(LT)和边缘触发(ET)的区别
LT模式：只要文件描述符还有数据可读，每次epoll_wait就会返回它的事件（只要有数据就触发）
ET模式：只有数据流到来的时候才触发，不管缓冲区是否还有数据（只有数据流到来才会触发）
